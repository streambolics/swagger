<html>
<head>
    <title>Resource</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<style>
        h1
        {
            page-break-before: always;
            border: 3px solid black;
            border-radius: 5px;
        }
	  	h2:before
		{
    		content:' ';
    		display:block;
    		border:2px solid black;
		}
        div.answer
        {
            background-color: aquamarine;
            margin-left: 80px;
        }
        td.answered
        {
            background-color: aquamarine !important;
        }
        td.unanswered
        {
            background-color: lightcoral !important;

        }
        div.note
        {
            background-color: aquamarine !important;
            border: 1px solid aquamarine;
            margin-right: 40%;
        }
        div.warning
        {
            background-color: lightcoral !important;
            border: 1px solid lightcoral;
            margin-left: 40%;
        }
    </style>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.2.6/mermaid.min.js"
        integrity="sha256-0EUu19CAux3g/iy/+6obKNgaGhv3E6yrHdNWBnZncE0="
        crossorigin="anonymous">
    </script>
</head>
<body>
<xmp theme="spacelab" style="display:none;">
This document contains useful information on the Resource service and its
usage.

|Date|Initials|Section|Changes|
|----|--------|-------|-------|
|<sub>31&#8209;MAY&#8209;2019</sub>|<sub>SLE</sub>|<sub>Main</sub>|<small>     Included the simplified API.     Added parallel with Polarion.|
|<sub>06&#8209;JUN&#8209;2019</sub>|<sub>SLE</sub>|<sub>Workflows</sub>|<small>     Reorganized the workflows.|
|<sub>06&#8209;JUN&#8209;2019</sub>|<sub>SLE</sub>|<sub>Main</sub>|<small>     Additional information about users, authorizations, home groups, etc.|
|<sub>11&#8209;JUN&#8209;2019</sub>|<sub>SLE</sub>|<sub>Swagger</sub>|<small>     Automatic generation of the swagger documentation.|
|<sub>21&#8209;JUN&#8209;2019</sub>|<sub>SLE</sub>|<sub>Swagger</sub>|<small>     Extended the resource links to allow custom sorting and selection of     preferred elements.|
|<sub>17&#8209;JUL&#8209;2019</sub>|<sub>SLE</sub>|<sub>Workflows</sub>|<small>     Initial description of the distinction between direct and inderect     connections.|
|<sub>18&#8209;JUL&#8209;2019</sub>|<sub>SLE</sub>|<sub>Workflows</sub>|<small>     Rewritten the distinction between direct and indirect connections according     to capabilities of new instrument drivers.|
|<sub>9&#8209;AUG&#8209;2019</sub>|<sub>SLE</sub>|<sub>All</sub>|<small>     Cleanup. Removed unneed techno-babble. Table of contents.|
|<sub>28&#8209;AUG&#8209;2019</sub>|<sub>SLE</sub>|<sub>IM&#8209;69373</sub>|<small>     Workflows involving middlewares acting as connection groups.|
|<sub>02&#8209;SEP&#8209;2019</sub>|<sub>SLE</sub>|<sub>IM&#8209;69687</sub>|<small>     Specification of IM-specific properties for connections.|
|<sub>02&#8209;DEC&#8209;2019</sub>|<sub>SLE</sub>|<sub>All</sub>|<small>     Miscellaneous clarifications.|
|<sub>17&#8209;FEB&#8209;2020</sub>|<sub>SLE</sub>|<sub>Swagger</sub>|<small>     Unimplemented REST APIs marked as such.|
|<sub>17&#8209;FEB&#8209;2020</sub>|<sub>SLE</sub>|<sub>Connection&nbsp;Groups</sub>|<small>     Added a paragraph about what connection groups are.|
|<sub>17&#8209;FEB&#8209;2020</sub>|<sub>SLE</sub>|<sub>IM&nbsp;Connections</sub>|<small>     Draft status removed|
|<sub>21&#8209;FEB&#8209;2020</sub>|<sub>SLE</sub>|<sub>IM&#8209;69650</sub>|<small>     Clarified limitations of the "includelinks" query parameter.|
|<sub>27&#8209;MAR&#8209;2020</sub>|<sub>SLE</sub>|<sub>IM&#8209;69351</sub>|<small>     DELETE operation now supported on the /connections simplified API.     Clarified the action of the "autocreate" parameter, and its possible     future deprecation.|
|<sub>23&#8209;APR&#8209;2020</sub>|<sub>SLE</sub>|<sub>ImConnections</sub>|<small>     Swagger documentation for the ImConnetions endpoint.|
|<sub>13&#8209;MAY&#8209;2020</sub>|<sub>DJR</sub>|<sub>IM&#8209;79280</sub>|<small>     Synchronizing new users from the identity provider now functional for "autocreate"|
|<sub>10&#8209;AUG&#8209;2020</sub>|<sub>SLE</sub>|<sub>Swagger</sub>|<small>     Swagger documentation completely rewritten. Now contains the all microservices in one     single document.|
|<sub>10&#8209;AUG&#8209;2020</sub>|<sub>SLE</sub>|<sub>Workflows</sub>|<small>     Workflows for mirror members & properties|
|<sub>31&#8209;AUG&#8209;2020</sub>|<sub>TKE</sub>|<sub>IM&#8209;84046</sub>|<small>     Add CurrentTenant endpoint and workflow for global settings.|

Contents
--------

  - [Workflows for applications displaying data](#display-workflows)
  - [Workflows for applications editing data](#editor-workflows)
  - [Workflows for applications providing data](#provider-workflows)
  - [The imconnections endpoint](#im-connections)
  - [Symbol reference](#resource-reference)
  - [API reference](#swagger)

About resources
===============

The `resource` service exposes definitions of _resources_. Resources represent
all physical or logical agents that participate to the work of the lab.

The concept of resource is quite broad, encompassing many objects that are
usually seen as distinct. Any answer to a question of the form "_who_ (performed/
should perform/is responsible for the correct execution of)
this action" is a resource. For example:

“Who provided this test result?”

- The result was hand typed by a lab technician. Therefore a lab technician is
  a resource.
- The result was provided by an instrument. Therefore, an instrument is a
  resource.
- The result was computed by a rule. Therefore, a rule is a resource.
- The result is the default value recommended by a SOP. Therefore, a SOP is
  a resource.

Typical resources include:

- Lab equipment such as instruments, decappers, centrifuges, refrigerated
  storage, etc.
- IT equipment such as desktop computers, servers, printers, signal converters
  (Lantronix), light poles, etc.
- Software services such as web servers, mail servers, shared file storage,
  lab middleware, etc.
- Manual or automatic procedures, such as IM rules, SOPs, etc.
- Organizational units such as labs, wards, boards of directors, etc.
- Users
- Ad hoc groups of other resources, such as “all the barcode printers on the
  second floor”.

Resource identity
-----------------

Resources have a formal identity known as their "Id". This identity can never
be changed, and does not depend on any of the editable properties of a
resource. More specifically, the identity does not depend on the name of the
resource, nor its relationships with other resources.

As a consequence, a resource can be renamed and moved in resource hierarchies
without altering its identity. Also, two resources may have the same name, the
system will still be able do disambiguate them according to their id.

The id is implemented as a UUID.

People vs Users
---------------

People are considered resources. They are different from _users_. While users
are indeed people and need to be considered resources, there are other people
that are tracked but that are not necessarily users of LabX.

A typical example is a requesting physician, that may be the person who ordered
some test on a specimen. This person needs to be tracked in the system, it is
a resource since it is the answer to the question “_who_ did this?” but is not
a user.

Resource Hierarchy
------------------

Resources are organized in an hierarchical way. Any resource (named _master_)
may oversee any number of sub-resources named _elements_. This is obviously true
for organizational units and groups, but is in fact extended to all possible
kinds of resources. This is useful when a resource needs to be described in
minute details. For example, an analyzer can be described as _containing_
multiple analytical units, a pipetting needle, a computer and a serial
interface, and the computer itself is _hosting_ a web service which _implements_
three REST interfaces that _expose_ a database. Note however that such level of
detail is not required for the software to work.

Similarly, element resources are _contained_ in any number of master
resources. This is the exact same relation seen from the other end.

Note that whether a resource is a master or an element is only meaningful in the
context of a link. A resource may be the master in one link, and the element
in another link.

One at most of these masters has a privileged relation to the contained
resource, and is known as its _parent_. The _parent_ relationship helps organize
the resources in a tree, that we call the _organization tree_. Element resources
inherit some properties of their parent, and are called _children_. For example,
unless told otherwise, we expect an organization to be in the same time zone as
its parent.

The relations are seen as going _down_ from a master to its elements, and
_up_ from the elements to their masters. No resource may relate to itself.

Recursive contents
------------------

A resource may contain element resources that are themselves masters. When
asking for the contents of a resource, a client usually only receives the
direct contents.

A client may ask for _recursive_ contents instead, in which sub-containers are
themselves resolved into their own content. Such recursion may expose the same
resource more than once if it is reachable using multiple paths. Also, recursive
contents has the risk of inducing cycles (resource A links down to B which links
down back to A)

Dynamic resources and proxies
-----------------------------

Some resources may represent another (set of) resources in a particular context.
For example, there may be a resource titled “Nearest printer”. This resource
represents another resource, namely the one being a printer, and being the
nearest to the current workstation.

Another such resource might be “All instruments currently offline”. This is
typically a group whose contents change over time.

Resource Kinds
--------------

Each resource has a kind (which is a definition) representing its typical
usage, for example “Person”, “Printer” or “Organizational Unit”.

The resource service does not limit the list of kinds of resources, nor does
it require any resource kind to be pre-defined. Client application and modules
are free to add any resource kind they see fit.

LabX itself does require some resource kinds to be defined; see the source code
for a list of those, along with their precise semantics.

Note also that it is sometimes possible to modify the resource kind of a
resource after its creation, especially for user created custom kinds.
However, since predefined resource kinds have a special meaning for the
software, changing the kind of a resource from “Connection” to “Pipetting
needle” might have strange effects and should be disallowed.

Relation Kinds
--------------

Each relation between a container resource and an element resource is known as
a link, and also has a kind. Typical link kinds include:

- the “Parent” links unite a parent with each of its children. Resources
  linked by this kind of relation form a tree structure (ie each resource has
  at most one such relation going upwards)

- The “Contains” links unite an ad-hoc group with each of its elements.

Note that while highly discouraged, nothing prevents a master to be linked to
the same element multiple times, with different relation kinds.

Database structure
------------------

<center>![Database structure](resource-database-structure.png)</center>

Parallel with Polarion items
----------------------------

While resources are quite different in in nature from Polarion work items, the
way they are organized is very similar.

<a name="3dc65525c34d54ba86159ece25a5183b"></a>
###Types

<center>![Types in Polarion](resource-polarion-type.png)</center>

The work item here has type “Code”. Polarion comes with some predefined types,
but additional ones can defined by the end user. It is possible, with some
restrictions, to change the type of a work item after it was created.
The equivalent in resources is the _Resource Kind_, which defines the purpose of
a resource, and can be changed later.

<a name="4fdd2d482f5550a79e84538e73233a94"></a>
###Links

<center>![Links in Polarion](resource-polarion-links.png)</center>

Each Polarion work item has links to any number of other items. The links also
have a type (in the _Role_ column) that is user defined and can be changed after
the link was created. The equivalent in resources are _Links_ and _Link Kinds_.

<a name="30f4b56a077d59e2afa615fb138b8802"></a>
###Navigation

<center>![Navigation in Polarion](resource-polarion-navigation.png)</center>

When displaying a Polarion work item, the list of its _masters_ (ie all other
Polarion work items that have an outgoing link to this item) is displayed above
the main title, and the list of its _elements_ (ie the list of all other
Polarion work items linked by this item) is displayed below. The user may
freely navigate the hierarchy of items.

Workflows for client applications displaying data
=================================================

<a name="display-workflows"></a>

These are the workflows that can be used by client applications that need to
display data on behalf of a user.


Preliminary Notes
-----------------

<a name="ecd90f7a14b65317ac8bb8992c76f323"></a>
####Guids
As usual, the actual parameters sent to a query are GUIDs. The workflows here
use the human readable versions using programmatic names enclosed in «» marks.

The mapping between programmatic names and actual GUIDs are in `resourceIds.js`.

<a name="30e0b9b3b5445a07b3094f574c6959fb"></a>
####Pagination

Remember that every time a collection of resources is returned, the list is
paginated.


Obtaining the connection groups for the current user
----------------------------------------------------

The simplified API:

    http://server/api/resource/1.0/connectiongroups

will return a list of resources that must be shown to the user as a pick
list for his choice of connection groups.

The returned set contains exactly what needs to be shown, and especially:

  * The first item in the list is the "home" or "preferred" group for the user.
  * Items are sorted according to the preferences of the user.
  * Items that the user is entitled to see, but chose to hide, are not present
    in the list.

Keep in mind that the resources returned here do not necessarily have their
Resource Kind equal to `ResourceKind_ConnectionGroup`. The items may in fact
be:

  * Automatically populated special purpose groups
  * Middlewares, which can be seen as the group of all connections managed by
    that middleware.

Obtaining the contents of groups
--------------------------------

There are two ways of obtaining the contents of the groups.

You can obtain the contents directly by using the

    http://server/api/resource/1.0/connectiongroups

query by including `includelinks=true` parameter in the URL:

    http://server/api/resource/1.0/connectiongroups?
        includelinks=true

In that case, each resource in the list will contain a `links` property that
contains an array of linked sub-resources. Enumerate that list and keep
the ones of kind `ResourceKind_Connection`. Note that this array contains at
most 100 links, even if the resource has more, and there is no way to apply
a filter.

You can also obtain the contents of a specific group at any time by calling:

    http://server/api/resource/1.0/resources/[Group-Id]/elements

Again, keep only the items of kind `ResourceKind_Connection`.
Obtaining the “Current User“ resource
-------------------------------------

This resource represents the current user. It is the root resources needed to
retrieve all what the user can do.

To retrieve the current user, issue a GET query to

    http://server/api/resource/1.0/currentuser

This will return a resource representing the current user. Parse the return
value and obtain its ID (and possibly, name). This will be used later as
`current-user-id`

Client Workflows for data providers
===================================

<a name="provider-workflows"></a>

These are workflows to be used by client applications that want to upload
data (esp. metrics). This particularly applies to ETL drivers.

Auto-creating Middleware and Connection resources
-------------------------------------------------

Before uploading metrics data, the client must obtain the GUIDs for the
related resources. The easiest way of doing this is to use the simplilfied
interface.

The client should first create the Middleware resource by deciding on a unique
code, then issuing a GET query to

    http://server/api/resource/1.0/middlewares/

Then create each connection known by the middleware by deciding on unique
codes, then issuing GET queries to

    http://server/api/resource/1.0/connections/


Auto-creating connections in the specific case of IM
----------------------------------------------------

The ETL driver uses the simplified interface during the synchronization phase,
then remembers the guids in memory. Next time the driver starts it can redo
the synchronization phase and it will receive back the same guids.


1.  Compute a unique code for the middleware itself. This would typically be
    built from the serial number. Be aware that the code must be the same for
    all mirror members (we are _not_ computing a code for individual members,
    but for the IM system as a whole)

2.  Issue a GET query to:

        http://server/api/resource/1.0/middlewares/[uniquecode]?
            autocreate=true&
            name=[Name of the middleware]

3.  Parse the returned data (which is a resource) and keep the id property.
    This id will be needed in the future queries as MiddlewareId.

4.  Iterate over all connections, direct or indirect. For each, compute a
    unique code. The unique code must be unique for the middleware, but two
    connections can share the same unique code if they are served from two
    different middlewares. For direct connections, the recommended code should
    contain the _Connection Number_ (101, 102, etc). For indirect connections,
    the unique code should be the Connection Number suffixed by the Instrument
    ID.

5.  Issue a GET query to:

        http://server/api/resource/1.0/connections/[uniquecode]?
            autocreate=true&
            middleware=[middlewareid]&
            name=[common name of the connection]

6.  Parse the returned data (which is a resource) and keep the id property.
    This is the Connection GUID.

<a name="21dda81971a45cf48a06f77bb7e33819"></a>
###Example

Issue the GET query for the IM middleware:

    GET http://server/api/resource/1.0/middlewares/SN-123456
        ?autocreate=true
        &name=Instrument%20Manager

Returns:

    {
    "statuscode": 201, "status": "Created", "errors": null,
    "data": {
        "id": "0465bc3c-6c40-55f5-9fb1-664c611a5401",
        "name": "Instrument Manager", "shortname": "", "systematicname": "SN-123456",
        "sortkey": "",
        "hrefs": [ { [...] } ],
        "kind": "b3115cba-34af-47ca-8405-f328858d6f89",
        "kindname": "Middleware",
        "links": []
        }
    }

Parse the id field and keep it: 0465bc3c-6c40-55f5-9fb1-664c611a5401. Pass it
to queries for connections

    GET http://server/api/resource/1.0/connections/CN-101
        ?middleware=0465bc3c-6c40-55f5-9fb1-664c611a5401
        &autocreate=true
        &name=Architect

Auto-creating Workstation resources for IM Mirror members
---------------------------------------------------------

To create IM mirror members:

1.  Use the /middlewares call to register IM as a middleware.
    You can of course reuse the id received from the call when registering
    connections.

2.  Register each mirror member using the /workstations API call. As uniquecode,
    use the network name of the station. Avoid using the IP address unless you
    are certain it will never change.

        http://server/api/resource/1.0/workstations/[uniquecode]?
            autocreate=true&
            middleware=[middlewareid]&
            name=[common name of the workstation]

3.  Upload additional information about the workstation that do not
    change often, and is not a metric, such as its IP addresses. Use
    a PUT the /properties API for these.

4.  Once this is done, the workstation object can be used to upload
    the metrics about the mirror member status.

Direct and indirect connections in the specific case of IM
----------------------------------------------------------

In some scenarios, IM connects some instruments through a secondary or
"daisy chain" connection. Examples include:

  - Abbott DMS
  - Roche CITM
  - A secondary Instrument Manager.

The lab user is interested in what happens at the instrument level, no
matter how many connections the results traversed. The IT user is interested
in the connections themselves.

To that purpose, LabX defines two broad flavors of connections:

  - _Direct_ connections are used to directly connect IM to an instrument
    or to a middleware. Direct connections in IM are actively connected to
    a communication port and use an instrument driver.
  - _Indirect_ connections are used to model the multi-hop connection between
    IM and the instrument.

There are two ways an IM driver can represent an indirect connection:

  - The most common case is to use a pair (Connection, Instrument ID). In
    that case, the connection defines a "Instrument ID map" to translate
    between the Insturment ID and the actual instrument. We call these
    _old style_ indirect connections.
  - Some newer drivers (including the one for Abbott DMS) use a connection map
    that define the indirect connections as true IM connections. We call these
    _new style_ indirect connections.

The ETL driver must therefore distinguish the following cases:

  - Direct connections, always corresponding to an IM connection with an active
    driver.
  - Old style indirect connections represented in IM as a pair (Direct
    Connection Number, Instrument ID).
  - New style indirect connections represented in IM as an inactive connection,
    fed with results from a direct connection with a new style driver.

Obviously, when setting up the Connection Groups, the administrator would
distribute the indirect connections in the groups he creates for the lab users,
and the direct connections he creates for IT users.

<a name="cbf1f8ef96ed5f328d2b4983b42910ae"></a>
### Metrics

The distinction between direct and indirect connections has impacts on how
metrics are uploaded from IM to LabX. A few examples include:

  - Queue sizes are irrelevant for indirect connections.
  - Connection status can be tricky for indirect connections. While it is
    obvious that when the corresponding direct connection is `Off`, all
    corresponding indirect connections are `Off` also, we cannot guarantee that
    an indirect connection is `On` just because the connection to the DMS is
    OK (the DMS itself may have trouble connecting the instrument).

Additional details about this can be found in the reference for the metrics
themselves.

<a name="bd136c80609f52dca1134905d1f3fab1"></a>
### Unique Code

The recommended method of generating unique codes passed to
`http://server/api/resource/1.0/connections/` is to use:

  - `CN-xxx` for direct connections, where xxx is the connection number in
    IM (101, 102, etc).
  - `CN-xxx` for _new style_ indirect connections.
  - `CN-xxx-yyyyy` for old style indirect connections, where xxx is the
    direct connection number and yyyyy is the instrument ID.

<a name="1386ec1c513151f599ea357c0cfba0f7"></a>
### Multiple connections to the same instrument

At the connection level, we do not try to be smart or group connections to
the same instrument. For example, if the `Abbott DMS orders` direct connection
also has entries in the Instrument Map, we would create three additional
indirect connections (`Architect c8000 1 through Abbott DMS orders`, etc.)
which would be distinct from the three previous ones.

A future extension of LabX will take care of that by explicitly defining the
actual instruments and linking them to all the connections used to connect
them. See the symbol references:

  - [#2af58fea-4240-4305-b7c4-5144457454cb](`ResourceKind_Instrument`)
    for resources representing instruments.
  - [#2924dd58-72f6-4c3d-93eb-cd2bfc1db3d9](`ResourceLinkKind_Connection`)
    for links between connections and instruments.

<a name="f68d17600fa75837a0d6a55c17c04da9"></a>
### When the secondary itself is able to report connection statuses

Imagine the case where the secondary itself is able to report the status of its
connections. This could occur because:

  - The secondary sends status messages about its internal state, that are
    interpreted by the IM driver and uploaded to LabX. We do not yet have
    a scenario for that.

  - The secondary is able to upload its status to LabX directly. This would
    occur if the secondary is itself an IM system customized for a business
    partner.

In that case, each connected instrument would correspond to three distinct
connections:

  - One _direct_ connection from IM to secondary.
  - One _indirect_ connection from IM to instrument (labeled "through DMS").
  - One _direct_ connection from secondary to instrument.

Each of these three connections must be represented in the database since they
are independent.

Simplified interface for obtaining GUIDS
----------------------------------------

Most APIs require knowing the GUID to a resource. Typically, the metrics API
requires knowing the guids of connections.

Display-only clients can simply query for the list of all available connections
using GET queries to the global resource items, but clients that need to
synchronize their configuration to the cloud need to somehow detect whether
a resource already exists in the cloud, and auto-create it otherwise.

Such clients may choose between two methods:

*   The full interface involves the client actively remembering the GUIDS of
    already created connections, and issuing POST queries to

        http://server/api/resource/1.0/resources

    to create new resources, then remembering the returned guids. The full
    interface is recommended, but can be hard to fully implement as it involves
    creating multiple objects and links, then securely storing the guids in
    the client.

*   The simplified interface involves issuing GET queries to specialized
    endpoints that will automate the retrieval and creation of resources and
    links based on a _unique code_. The client is no longer required to remember
    the guids across sessions, but is required to devise a method for creating
    unique codes.

The simplified API queries retrieve or create a new resource in the cloud
configuration based on a _unique code_. They simplify the work of the client by
automating the setting of many key properties of the resources and link them
together.

However, for the correct function of the simplified API, the client is
responsible for providing _unique codes_ that fulfill the following
prerequisites:

*   They consist only of latin letters, digits, dashes (-) and dots (.). The
    codes are case sensitive: `abc` is different from `ABC`
*   They are truly _unique_ (at least for a tenant, but it is recommended for
    them to be unique in the whole world)
*   They are _unchanging_. If the unique code ever changes, the simplified API
    will not be able to retrieve the old resource and will create a new one.

It is therefore recommended that a unique code is built using internal identity
of the objects, not on user-defined names.

All simplified API calls share the following common properties:

*   They are accessed through the `GET` verb, although sometimes they will
    create new resources.
*   The `autocreate` field ensures that the resource is created if none exists
    with the given unique code.
*   The `name` field is used to provide a default name. The name is only used
    when initially creating the resource. If the resource is already existing,
    its name is not changed.
*   The status code can be used to check whether the resource was pre-existing
    (`200 - Success`) or was just created (`201 - Created`)
Workflows for client applications editing the configuration
===========================================================

<a name="editor-workflows"></a>

These are the workflows that can be used to edit the configuration


Preliminary Notes
-----------------

<a name="ecd90f7a14b65317ac8bb8992c76f323"></a>
####Guids
As usual, the actual parameters sent to a query are GUIDs. The workflows here
use the human readable versions using programmatic names enclosed in «» marks.

The mapping between programmatic names and actual GUIDs are in `resourceIds.js`.

<a name="30e0b9b3b5445a07b3094f574c6959fb"></a>
####Pagination

Remember that every time a collection of resources is returned, the list is
paginated.


Retrieving the list of all users
--------------------------------

    http://server/api/resource/1.0/users?autocreate=true

This synchronizes all users from the logon provider. Users can also be
retrieved from:

    http://server/api/resource/1.0/resources?kind=«ResourceKind_User»

but this will _not_ synchronize from the identity provider, only return the
users already present.

Retrieving the list of all connections
-------------------------------------

Issue a GET to:

    http://server/api/resource/1.0/resources?kind=«ResourceKind_Connection»

This API is only available to administrators. It will return all
connections defined in the system, including those not displayed on that user's
dashboard.

Note : in the specific case of IM, it is possible to obtain the list of
connection with additional IM-specific properties. See the documentation
for the [imconnections](#im-connections) endpoint.

Retrieving the list of all connection groups
--------------------------------------------

Issue a GET to:

    http://server/api/resource/1.0/resources?kind=«ResourceKind_ConnectionGroup»

This API is only available to administrators. It will return all connection
groups defined in the system, including those that do not appear on the
dashboard for that user.

Editing the contents of a connection group
------------------------------------------

To rename a connection group, issue a PUT to:

    http://server/api/resource/1.0/resources/«group-id»

with body:

    {
        name: "«new name»"
    }

To add a connection to a group, issue a POST to:

    http://server/api/resource/1.0/resources/«group-id»/links

with body:

    {
        element: "«connection-id»"
        linkkind: "«ResourceLinkKind_Content»"
    }

To remove a connection from a group, issue a DELETE to:

    http://server/api/resource/1.0/resources/«group-id»/links?
        element=«connection-id»&
        linkkind=«ResourceLinkKind_Content»


Allowing a user to monitor a connection group
---------------------------------------------

To allow a group for a user, issue a POST to:

    http://server/api/resource/1.0/resources/«user-id»/links

with body:

    {
        element: "«group-id»",
        linkkind: "«ResourceLinkKind_ReadAccess»"
    }

To remove a group from the user, issue a DELETE to:

    http://server/api/resource/1.0/resources/«user-id»/links?
        element=«group-id»&
        linkkind=«ResourceLinkKind_ReadAccess»

Retrieving the "Current Tenant" resource
----------------------------------------

This resource represents the current tenant. It is the root resource needed to
retrieve or store global settings.

To retrieve the current tenant, issue a GET query to

    http://server/api/resource/1.0/currenttenant

This will return a resource representing the current tenant. Parse the return
value and obtain its ID. This will be used later as `tenant-id`.

To retrieve and store global settings (attached to the current tenant), issue
a GET or a PUT to

    http://server/api/resource/1.0/properties/«tenant-id»/«property-id»
(see the chapter about resource properties for details).

Getting and setting additional resource properties
--------------------------------------------------

To set the value of an additional property, issue a PUT to

    http://server/api/resource/1.0/properties/«resource-id»/«property-id»

The body should be the value of the property, which is any JSON value,
including arrays and/or records.

To retrieve the value of an additional property, issue a GET to
the same API.

The Property ids need to correspond to a Resource Property Kind, that
can be managed with the

    http://server/api/resource/1.0/propertykinds

and

    http://server/api/resource/1.0/propertykinds/«property-id»

CRUD APIs.
The ImConnections endpoint
==========================

<a name="im-connections"></a>



This simplified endpoint provides tools to manage resources of kind
`ResourceKind_Connection` according to the IM worldview. This is done mainly
through additional resources and links, that are exposed as named properties
by the simplified interface.

<div class="warning">
    This API is meant to be used during setup. Since calling this API hits many
    different tables in the resource module, it may be inefficient for routine
    use.
</div>

Rationale
---------

Using resources to represent additional informations simplifies the navigation
in the organizational view. For example, given a site, it becomes immediately
possible to navigate to its connections, without the need of additional APIs.

Also, additional information being resources having connections as elements
allows to define metrics and or KPIs on those. It becomes feasible to have KPIs
on sites, locations, drivers, etc.

General view
------------

This is a general view of the relations used to represent IM specific data.
The following sections each describe relatede sets of these relations.

<div class="mermaid">
    graph TD
        classDef Connection fill:#39f,stroke:#000;
        classDef Configuration fill:#3fc,stroke:#000;
        classDef Software fill:#fc6,stroke:#000;
        classDef Organization fill:#9f3,stroke:#000;

        soft[diiastmi]
        softv1[v8.15.004]
        softv2[v8.15.005]
        class soft,softv1,softv2 Software

        soft-->|Version|softv1
        soft-->|Version|softv2

        conf1[Architect]
        conf2[Centaur]
        conn1[Architect 1]
        conn2[Architect 2]
        conn3[Centaur 1]

        class conf1,conf2 Configuration;
        class conn1,conn2,conn3 Connection;

        softv1-->|Instance|conf1
        softv2-->|Instance|conf2
        conf1-->|Configuration|conn1
        conf1-->|Configuration|conn2
        conf2-->|Configuration|conn3

        site1[Alpha Site]
        site2[Omega Site]
        location1[Main location]
        location2[First Floor]
        location3[Second Floor]

        class site1,site2,location1,location2,location3 Organization;

        site1-->|Child|location1
        site2-->|Child|location2
        site2-->|Child|location3

        site1-->|Site|conn1
        site2-->|Site|conn2
        site2-->|Site|conn3

        location1-->|Location|conn1
        location2-->|Location|conn2
        location3-->|Location|conn3

        subgraph Legend
            x_conn[Connection]
            class x_conn Connection
            x_org[Organization]
            class x_org Laboratory
            x_conf[Configuration]
            class x_conf Configuration
            x_soft[Software]
            class x_soft Software
        end
</div>

Sites and locations
-------------------

Each connection may be attached to a _site_ and a _location_. LabX represents
these as resources of kind `ResourceKind_Laboratory`, and links them
to the connections using links of kind `ResourceLinkKind_Site` and
`ResourceLinkKind_Location`. Note that the site and location are the masters
and the connections are the elements, as one site may contain any number
of connections but a connection only belongs to one site.

<div class="mermaid">
    graph TD
        classDef Connection fill:#39f,stroke:#000;
        classDef Configuration fill:#3fc,stroke:#000;
        classDef Software fill:#fc6,stroke:#000;
        classDef Organization fill:#9f3,stroke:#000;

        conn1[Architect 1]
        conn2[Architect 2]
        conn3[Centaur 1]
        class conn1,conn2,conn3 Connection;

        site1[Alpha Site]
        site2[Omega Site]
        location1[Main location]
        location2[First Floor]
        location3[Second Floor]

        class site1,site2,location1,location2,location3 Organization;

        site1-->|Child|location1
        site2-->|Child|location2
        site2-->|Child|location3

        site1-->|Site|conn1
        site2-->|Site|conn2
        site2-->|Site|conn3

        location1-->|Location|conn1
        location2-->|Location|conn2
        location3-->|Location|conn3

        subgraph Legend
            x_conn[Connection]
            class x_conn Connection
            x_org[Organization]
            class x_org Laboratory
            x_conf[Configuration]
            class x_conf Configuration
            x_soft[Software]
            class x_soft Software
        end
</div>

Configurations and Drivers
--------------------------

Each connection is defined by a _configuration_. Each configuration uses a
driver. All these are again represented as resources.

<div class="mermaid">
    graph TD
        classDef Connection fill:#39f,stroke:#000;
        classDef Configuration fill:#3fc,stroke:#000;
        classDef Software fill:#fc6,stroke:#000;
        classDef Organization fill:#9f3,stroke:#000;

        soft[diiastmi]
        softv1[v8.15.004]
        softv2[v8.15.005]
        class soft,softv1,softv2 Software

        soft-->|Version|softv1
        soft-->|Version|softv2

        conf1[Architect]
        conf2[Centaur]
        conn1[Architect 1]
        conn2[Architect 2]
        conn3[Centaur 1]

        class conf1,conf2 Configuration;
        class conn1,conn2,conn3 Connection;

        softv1-->|instance|conf1
        softv2-->|instance|conf2
        conf1-->|configuration|conn1
        conf1-->|configuration|conn2
        conf2-->|configuration|conn3

        subgraph Legend
            x_conn[Connection]
            class x_conn Connection
            x_org[Organization]
            class x_org Laboratory
            x_conf[Configuration]
            class x_conf Configuration
            x_soft[Software]
            class x_soft Software
        end
</div>

Backend implementation
----------------------

<div class="note">
  This section is part of the design task and not a specification.
</div>


Create a new endpoint at the URL:

    http://server/api/resources/1.0/imconnections/:id

This endpoint exposes Connection resources with additional fields as expected
for IM. The endpoint supports three operations:

  * `GET` without the :id parameter, returns all connections defined in LabX,
    subject to paging.
  * `GET` with the :id parameter, returns the connection identified by the given
    guid.
  * `PUT` with the :id parameter, updates the properties of the connection.

Besides the usual properties of resources, the endpoint adds the following:

  * `site`, `sitename`, `sitecode`: The id, the name and the unique code for the "Site" property
    of an IM connection.
  * `location`, `locationname`, `locationcode`: the id, the name and the unique code for the "Location"
    property of an IM connection.
  * `configuration`, `configurationname`, `configurationcode`: the id, name and unique code for the configuration
  * `driver`, `drivername`, `drivercode`, `driverversion`: the id, name and unique code for the driver version.

The endpoint shall:

 1. Update the name of the connection with the given `name` parameter.
 1. Create resource for the site, generating the id by hashing the `sitecode`
    with the `ResourceKind_Organization` namespace. Make the site the parent of
    the connection, with a link of kind `ResourceLinkKind_ImSite`
 1. Create a resource for the location, by hashing the `locationcode` with the
    id of the site and `ResourceKind_Organization` as namespace. Make the
    location a parent of the connection, with `ResourceLinkKind_ImLocation`.
 1. Create a resource  for the configuration by hashing the `configurationcode` with
    the id of the middleware and `ResourceKind_Configuration`. Make the
    configuration a parent of the connection, with `ResourceLinkKind_Configuration`
 1. Create a resource for the driver hashing the code using `ResourceKind_Software`.
    Do the same for the version, link them with `ResourceLinkKind_Version`. Link
    the version to the configuration with `ResourceLinkKind_Instance`.

Single Masters
--------------

The design relies on the presence of _Single Masters_, ie relations where any
resource has at most one master through a given link kind. For example, a
connection has at most one master through the `ResourceLinkKind_ImLocation`
relation. That means that if a PUT operation specified a new master, the old
master must be unlinked.

Create a utility function `LinkSingleMaster (Element, Master, Kind)` that:

  1. Deletes all existing links from any master to Element with the given kind
  2. Creates a link from Master to Element with the given kind.

Create a utility function `GetSingleMaster (Element, Kind)` that:

  1. Returns the (single) master of Element with the given kind.

Workflow for the ETL driver
---------------------------

<div class="note">
  This section shall be moved to the "ETL workflows" chapter.
</div>


After accessing each of the connections, the ETL driver should update the
information for an IM connection by issuing a PUT with the following
properties:

  * `name`: the name of the connection.
  * `sitename`: the (unique) name of the site
  * `locationname`: the (unique) name of the location
  * `configurationcode`: the unique code for the configuration. This must be unchanging (ie the internal number of the configuration,
    prefixed by `CC-`)
  * `configurationname`: the name of the configuration. This name may change.
  * `drivercode`: the internal code name for the driver, for example "diiastmi"
  * `driverversion`: the full version of the driver, for example "v8.15.004"
  * `drivername`: the name of the driver, without the version, for example "Configurable ASTM driver"

<div class="mermaid">
    sequenceDiagram
        participant ETL
        participant Backend

        ETL->>Backend: GET middlewares/:code
        Backend->>ETL: Middleware resource id

        loop Connections

            ETL->>Backend: GET connections/:code
            Backend->>ETL: Connection resource id
            ETL->>Backend: PUT imconnections/:id

        end
</div>

Example payload to `imconnections`:

    PUT http://server/api/resource/1.0/imconnections/3f45-xxxx-yyyyyyyy
    {
        "name": "Architect 1",
        "sitename": "West Coast",
        "locationname": "First Floor",
        "configurationcode": "CC-101",
        "configurationname": "Architect",
        "drivercode": "diiastmi",
        "driverversion": "v8.15.004",
        "drivername": "Configurable ASTM driver"
    }

What is a connection group?
===========================

A connection group is a configuration item that allows you to group together
a set of _connections_ in order to monitor them as a whole.

To monitor a connection group, LabX defines a set of KPIs. Each of these KPIs
are an indicator of the health of a lab process, in relation to the connections
in the group. For example, one of the KPIs allows you to see how well
auto-verification works for the connections of the group.

Manually defined connection groups
----------------------------------

Connection groups reflect the organization of your lab, so it is up to you
to define relevant groups and insert the appropriate connections in the group.

 -  A connection group can contain connections from multiple different IM
    middlewares. You may build a group of all your hematology instruments, even
    if they are connected by multiple different IMs.

 -  The order in which connections are inserted into a connection group is
    irrelevant, they are all treated the same.

 -  You can insert a connection in any number of connection groups. You may have
    a connection group for all hematology instruments, and one group for all
    emergency instruments; a hematology instrument used in the ER would be in
    both groups.

 -  You cannot insert the same connection twice in the same connection group.

Automatically defined connection groups
---------------------------------------

In order to simplify the initial setup of connection groups, the LabX system
automatically creates a range of configuration items that you can choose to use
as a connection groups. Contrary to user-defined groups:

 -  You are not allowed to manually alter the contents of the group directly
    in LabX.

 -  The contents of the group are altered according to external setup performed
    on the IM middleware itself. For example, if you alter a connection in
    IM and change its _location_ field from **first floor** to **second floor**,
    the connection will automatically be removed from the connection group named
    "first floor" and will be added to the connection group named "second floor".

<div class="note">
Note that due to delays in the transmission of data from the IM middleware to
the LabX cloud, the propagation of the changes from IM to the connection groups
may take up to a few minutes.
</div>

The LabX cloud automatically maintains the following connection groups:

  - A _middleware_ connection group for each of the known middlewares (IMs). This
    group contains _all_ connections managed by that middleware, including system
    connections such as QMGR and Purge.

  - A _location_ and a _site_ connection group for each of the locations and
    sites defined in the IM setup of connections. The group contains all
    connections that share the same site, or share the same site _and_ location.
    The group may contain connections from multiple different IMs.

  - A _configuration_ connection group for each of the configurations defined
    in IM. The connection group contains all connections that use that
    configuration.


Symbol reference
================

<a name="resource-reference"></a>
This section contains the list of known kinds for resources and resource
links.

Resource Kinds
--------------

<a name="87f5b70d-3069-4d57-86d4-baf6edc9144e"></a>
<a name="39f35bde1dd8554eb17bd7a7b9687adf"></a>
###ResourceKind_AnalyticalProcessMonitor
    GUID: '87f5b70d-3069-4d57-86d4-baf6edc9144e'
An _Analytical Process Monitor_ is software that monitors the analytical
processes in instruments to verify that the instrument works as expected.
<a name="88660668804e59b3bf31accead86bf18"></a>
# Examples
-   EP Evaluator
-   LQC
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Monitor --> Instrument

<a name="f8dd9786-bf8e-4ef8-897f-afedb6542d25"></a>
<a name="a2bc482941c45344ae19586357c54db5"></a>
###ResourceKind_AnalyticalUnit
    GUID: 'f8dd9786-bf8e-4ef8-897f-afedb6542d25'
An _Analytical Unit_ is a sub-part of an instrument responsible for the
internal handling of the analytical process.
An instrument can be divided in analytical units either physically (the
whole instrument is composed of a juxtaposition of multiple similar units)
or logically (the instrument uses multiple different paths for the specimen).
A typical example of a logical division is when an instrument has two sampling
needles, one for specimens loaded on the automatic feeder, and one for manually
fed STAT specimens.
<a name="11c3c02256ba5614b5aa884a56702e86"></a>
# Rationale
The distinction of several sub-units is important when monitoring the performance of
individual units, typically for standard QC and EP evaluator.
In the case of EP Evaluator, having multiple sub-units is important when doing method
comparison, eg to verify that results obtained using the automatic loader are the same
as those obtained using the manual STAT loader.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Component <-- Instrument

<a name="73361d2f-800d-4b6a-a219-222f8adb632c"></a>
<a name="2819a43ea63b5349943c7d9f2e006fef"></a>
###ResourceKind_Asset
    GUID: '73361d2f-800d-4b6a-a219-222f8adb632c'
An _Asset_ represents a customer.

<a name="1389ad81-7863-4d2e-ad8d-5c96df1cadff"></a>
<a name="6e2a90ffdb0157a69ac036920396bba0"></a>
###ResourceKind_Configuration
    GUID: '1389ad81-7863-4d2e-ad8d-5c96df1cadff'
A _Configuration_ resource represents the configuration of a connection.

<a name="6acd880f-1c33-44f9-b194-914c061fcc9d"></a>
<a name="8d0bc426024d5dba964fb69d4d4da5c1"></a>
###ResourceKind_ConfigurationProduct
    GUID: '6acd880f-1c33-44f9-b194-914c061fcc9d'
A _Configuration Product_ is a configuration that can be delivered to a customer.

<a name="8ac62bd9-9ada-497c-8431-4883391e5704"></a>
<a name="c37bca02df5b59118a377fb8d2d2d3f8"></a>
###ResourceKind_Connection
    GUID: '8ac62bd9-9ada-497c-8431-4883391e5704'
A _Connection_ is a software module that connects an external device so
that orders can be transmitted and results can be retrieved. A connection
is typically used to exchange such data with analytical instruments,
LISes or other middlewares.
Connections are managed by larger software modules. In the current version
of LabX, the only software modules that can manage connections are
middlewares, but other kinds of resources (LIS, quality managers such as
EE) will be able to do that in the future.
<a name="90a5318c6cfe5cee93c93e0a573feae2"></a>
# Owner
The owner of a Connection is the Middleware or LIS that hosts it.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Component <-- Middleware
-   Connection --> Instrument
-   Connection --> Middleware The connection allows its owner middleware
    to communicate with another middleware.
<a name="41f2c43ab48451f9a09c00a4adb18eae"></a>
# Metrics
 -   ResultsReleased
<a name="189c8741c6dc5c3e9fefce86326f440c"></a>
# KPIs
 -   SpecimensHeld
 -   CriticalSpecimensHeld

<a name="5f00f658-4d33-4690-bc99-570097d92de9"></a>
<a name="519ba9c94cf95dfd908bddf95da8affa"></a>
###ResourceKind_ConnectionGroup
    GUID: '5f00f658-4d33-4690-bc99-570097d92de9'
A _Connection Group_ is a grouped resource that represents a set of
connections that are usually handled as a whole.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Content --> Connection
    The main purpose of a connection group is to contain connections

<a name="eb90752d-230e-4534-9e27-3d83f8e6b50a"></a>
<a name="7a9cb079fa255d7f856bf8ef2f7da9d8"></a>
###ResourceKind_DataFile
    GUID: 'eb90752d-230e-4534-9e27-3d83f8e6b50a'
A _Data File_ is the storage space (is usually a file) where the actual
data is kept.
<a name="fa26bc45bce2563a97c9999c3e467579"></a>
# Usage
Data files are usually found as the backend data storage of databases,
through tablespaces. They can also be used for other purposes, such as
virtual memory.
Note that datafiles represent permanent structure. A PDF file holding an
export of a report requested by the user is not a datafile.
<a name="e717e1d7ef095bb6be25ba35a662b4ac"></a>
## Instrument Manager
A typical datafile is the `CACHE.DAT` file in which actual data is stored.
For technical reasons, a Caché Tablespace only contains a single Datafile,
but that may change with sharding and/or the move away from Caché.
Note however that a Caché database (ie a Tablespace resource) contains
more than just the Datafile: it contains also journaling logs, etc.
<a name="5bb43e59817f58e09f71a5e2dc52bf8e"></a>
## LPM
A Datafile corresponds to an Oracle Datafile. A single Tablespace may
contain any number of Datafiles.
<a name="ddb0fc902855508cb411d196cae09095"></a>
## EP Evaluator
EP Evaluator stores data in distinct "isam" files. Each of those files is
a DataFile.
<a name="11c3c02256ba5614b5aa884a56702e86"></a>
# Rationale
Datafiles need to be monitored because they have an inherent limit on the
quantity of data they can hold. Datafile can either have a predetermined
fixed size, or allowed to grow within certain limits.
Datafiles growing too large, or fixed size datafiles becoming full are
potential problems that can cause downtime, and need addressing.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Component <-- TableSpace
    A database TableSpace needs storage for the data, and uses one or more
    data files to do so.
-   Host <-- DataVolume
    Most datafiles are stored on a file system, and thus have a file name, etc.
-   Host <-- Partition
    Some systems, like database servers and virtual memory can put their data files directly
    into a raw partition. This removes the overhead of a file system.
    Doing so is more common in Unix-like systems than in Windows.

<a name="42f0c08a-7c50-4c1e-a8c8-161de3a93e7b"></a>
<a name="3863878cf440525a959052e3057b15bc"></a>
###ResourceKind_DataVolume
    GUID: '42f0c08a-7c50-4c1e-a8c8-161de3a93e7b'
A _Data Volume_ is physical storage space where files can be kept.
A DataVolume can be:
-   A partition on an HDD or SSD.
-   A logical drive allocated in a SAN
-   A virtual drive in a VM.
-   A RAID assembly
<a name="5f756861907e5d72b3c31ecf58bca0f6"></a>
# Mounted volumes
A Datavolume is not used for remote volumes that are made available from
another workstation. For example:
- Workstation `SRV` has a partition C:. This is represented by a Datavolume
  hosted on SRV. This volume is exposed by a network share.
- Workstation `CLI` connects to SRV and mounts the network share as N:. N:
  is not represented by a Datavolume.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Component <-- Workstation
    A Data Volume is part of the workstation. Most workstations have one preferred
    data volume they call the "system drive" or "root drive".
-   Host <-- Partition
    A Data Volume is typically hosted in a disk partition. The volume occupies all
    available space in that partitiion.

<a name="3f15b9e1-b0cf-4581-9592-c9f206e22945"></a>
<a name="055f835ed9e15937b124194ffa836d08"></a>
###ResourceKind_Database
    GUID: '3f15b9e1-b0cf-4581-9592-c9f206e22945'
  A _Database_ resource represents a collection of data used by an application.
  A database can be either self-hosted (such as SQLite databases) or managed
  by a database server such as Oracle, Caché, Postgres, etc.
<a name="88660668804e59b3bf31accead86bf18"></a>
# Examples
<a name="e717e1d7ef095bb6be25ba35a662b4ac"></a>
## Instrument Manager
In Instrument Manager, there is one Caché database per mirror member.
Note that what Caché calls a database is represented as a Tablespace in
LabX. What LabX calls the database more precisely corresponds to what
Caché calls the "IM Namespace".
<a name="5bb43e59817f58e09f71a5e2dc52bf8e"></a>
## LPM
In LPM, there is one Oracle database per Dataguard cluster member. LPM also
uses some local databases (eg the Analyzer Run Databases, the Input Fifos) that
could also be represented by database resources.
<a name="ddb0fc902855508cb411d196cae09095"></a>
## EP Evaluator
Each EP Evaluator project is a database. These are self hosted databases managed
by a library known as DB-ISAM.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Component <-- Middleware
-   Host <-- Workstation

<a name="2095bb5f-bd9f-4633-ab6a-895b8b498abb"></a>
<a name="b40c09de795e54488c6ced5630abbd10"></a>
###ResourceKind_Disk
    GUID: '2095bb5f-bd9f-4633-ab6a-895b8b498abb'
A _Disk_ is a physical or virtual disk drive containing partitions.
<a name="11c3c02256ba5614b5aa884a56702e86"></a>
# Rationale
Disk drives need to be monitored along the following axes:
-   SMART characteristics and Temperature. This may preventively detect
 failures.
-   Communication channel performance and usage
Note that it is usually unnecessary to monitor the size and usage of
storage space, as disks are divided in fixed partitions. It is therefore
recommended to monitor free space on data volumes hosted by those partitions.
In the case of a virtual disk, it may be interesting to monitor the
data file that is used as backing storage.

<a name="1294ed5b-40da-4f52-9f6d-822994a985dd"></a>
<a name="6ffceadc0f0554648448d0313a313e20"></a>
###ResourceKind_Dummy
    GUID: '1294ed5b-40da-4f52-9f6d-822994a985dd'
A _Dummy_ resource is a resource entry that is only useful for testing
purposes. The LabX software will never attach any particular meaning to
dummy resources.
Dummy resources should only be created in test databases. They can - and
should - be deleted quickly. Any resource of this kind, created more than
24 hours ago is susceptible of being removed from the database, along with
all its corresponding resource links.
It is the only resource kind that can actually be deleted from the
database.

<a name="9f20ce5f-54bd-4567-a04f-a2d4f2c21252"></a>
<a name="cfab45d9fe045c408812ec0f3e815daf"></a>
###ResourceKind_HomeConnectionGroup
    GUID: '9f20ce5f-54bd-4567-a04f-a2d4f2c21252'
A _Home Connection Group_ is a connection group specifically designed to
serve as the landing page for a user. **This feature was deprecated** in
favor of using middlewares as default connection groups. It was meant as a
group containing all connections a user can monitor.
There was one such Home Connection Group for each user. Its contents was
derived automatically from all other groups the user has access to.
<a name="90a5318c6cfe5cee93c93e0a573feae2"></a>
# Owner
The owner of a Home Connection Group is the corresponding user.
<a name="fa26bc45bce2563a97c9999c3e467579"></a>
# Usage
Home Connection Groups are not implemented.

<a name="2af58fea-4240-4305-b7c4-5144457454cb"></a>
<a name="c64a95aaa1fe5b02943846990e63fd6d"></a>
###ResourceKind_Instrument
    GUID: '2af58fea-4240-4305-b7c4-5144457454cb'
An _Instrument_ is a laboratory device that is able to analyze specimens
and produce results.
Instruments are typically connected to a middleware or directly to an LIS,
through one or more connections.
Note that it is not required that instruments are defined in order for
LabX to work.
<a name="91b963d6024d5bb697e39a7d63d5e3a8"></a>
# Instrument Manager
IM only uses connections. This is a limitation when multiple connections
are used to connect the same actual device.
<a name="0842816b5d675b54a2c2d89d0c043b14"></a>
# LPM
While LPM has the notion of "analyzer", what LPM calls an analyzer is
not an instrument: LPM uses analyzers to connect automation lines, etc.
Moreover, some instruments use multiple analyzers when multiple
communication lines are used.
As such, an LPM analyzer should be mapped to a connection, not an
instrument.
However, when using QC, what is monitored is the instrument, not the
connection. See LQC discussion.
<a name="62c37009c4115245b9020b4ed3d280b8"></a>
# EP Evaluator
EP evaluator uses instruments.
<a name="65e37010b1ad51bd8c3936ee7ee7c571"></a>
# LQC
What LQC calls an "analyzer" is an instrument. This is in contrast with LPM
that shares the same concept of analyzer.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
Connect <-- Connection

<a name="b99fcd5f-4dc5-485d-bf3a-1fb462a5e175"></a>
<a name="1ac7ca4fe8dc543ab899d72da47b4d01"></a>
###ResourceKind_Laboratory
    GUID: 'b99fcd5f-4dc5-485d-bf3a-1fb462a5e175'
A _Laboratory_ is an organizational unit that performs scientific
measurements on specimens that are brought from the outside, and produces
reports about the results of said measurements.
As such, it is responsible for the correct operation of the test equipment
performing those measurements, including the review of results for
discrepancies, maintenance of the equipment, assessment of the performance
of said equipment, etc.
Laboratories are usually specialized in some kinds of measurements. This
specialization is not formally represented in LabX. Most laboratories
known to LabX perform medical measurements on samples drawn from humans or
animals, but nothing precludes using LabX for laboratories that monitor
environmental factors such as air quality.
Laboratories are usually organized as a master organization ("the lab")
that oversees an ensemble of more specialized labs ("biochemistry lab",
"hematology lab", "emergency lab", etc.)

<a name="b3115cba-34af-47ca-8405-f328858d6f89"></a>
<a name="6c412f8b9eef5f03acb53b603e73eedb"></a>
###ResourceKind_Middleware
    GUID: 'b3115cba-34af-47ca-8405-f328858d6f89'
A _Middleware_ is a software module that manages the instrument connections
within a laboratory, but is not usually sufficient to handle all
aspects of laboratory management. Typically a middleware would not include
tools for invoicing, roster management, etc. and instead focuses only
on routing orders and results across connections.
In LabX, the most common middleware encountered is _Instrument Manager_,
but other middlewares such as _JResultNet_, _LPM_, or _Abbott DMS_ could
be represented also.
In the specific case of Instrument Manager, the Middleware resource
represents the IM system as a whole, including all members of the mirror
set, all thin clients, all optional add-ons, etc. In the future, the
individual components of the system (especially each member of the
mirror set) will be represented by sub-resources.
Note that the case of EP Evaluator is not clear yet. While EE can manage
instrument connections, its main goal is not to manage the connections
themselves.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Component --> Workstation
    A middleware runs on one or more workstations; most of them typically
    being large servers in a data center. A middleware usually runs on
    multiple such workstations forming a cluster (aka mirror set) for
    redundancy. Each workstation has a definite role.

<a name="11e92349-ac51-4aeb-b450-c48863d7ed6b"></a>
<a name="0c25429c7679513a8f0aa221cb0b2654"></a>
###ResourceKind_MiddlewareGroup
    GUID: '11e92349-ac51-4aeb-b450-c48863d7ed6b'
A _Middleware Group_ is a user managed collection of middlewares that are
to be monitored as a whole.

<a name="f64fe2a3-57a3-42ba-bff4-9e48b14c9e2e"></a>
<a name="a585b5cf634252d7a995dfd4b0342a68"></a>
###ResourceKind_Partition
    GUID: 'f64fe2a3-57a3-42ba-bff4-9e48b14c9e2e'
A _Partition_ is a logical segment within a disk, where data volumes
or swap memory can be hosted.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Host <-- Disk
-   Host --> DataVolume

<a name="94702439-8791-4fbb-8d49-c41b5cdf2453"></a>
<a name="d37173806fc35467a8e385eed66d6f00"></a>
###ResourceKind_PhysicalMemory
    GUID: '94702439-8791-4fbb-8d49-c41b5cdf2453'
The _Physical Memory_ is the internal data storage of a computer consisting
of the physical RAM useable by application programs and the Operating
System, excluding all virtual memory.
<a name="11c3c02256ba5614b5aa884a56702e86"></a>
# Rationale
Physical memory becoming full may degrade the performance of the applications
because part of memory must be offloaded secondary storage.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Component <-- Workstation

<a name="8b46c098-7c38-49ad-a4e5-5711b6c9a93c"></a>
<a name="a2d477bb74785eb495ebb587b391e7b0"></a>
###ResourceKind_Process
    GUID: '8b46c098-7c38-49ad-a4e5-5711b6c9a93c'
A _Process_ represents a generic software component that runs on a
(group of) workstations to provide some kind of service.
<a name="88660668804e59b3bf31accead86bf18"></a>
# Examples
A web server, a FTP server, a Docker cluster.
<a name="26c2fcb377ab5c01a67893035b4c37d9"></a>
# Refinements
Many kinds of processes are more finely known by LabX and thave their
own Resource Kind : middlewares, connections, etc.

<a name="f9608440-aff8-44c2-baea-3420474728c9"></a>
<a name="e139e4b4788357c5b942f3fc9d144e80"></a>
###ResourceKind_Processor
    GUID: 'f9608440-aff8-44c2-baea-3420474728c9'
A _Processor_ is the execution unit of a workstation.
<a name="3383675838f85fadbae4f663d59f2fed"></a>
#  Rationale
Processor resources are used as components of a workstation to represent
the computing resources of the workstation. A processor needs to be
monitored for percentage of usage and for temperature.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Component <-- Workstation

<a name="bea94d6e-ceb5-481b-87ce-791922ca6b53"></a>
<a name="0ea3a35f2b425fb5b39f2d5cb52b900d"></a>
###ResourceKind_RuleSet
    GUID: 'bea94d6e-ceb5-481b-87ce-791922ca6b53'
A _Ruleset_ is the list of rules used by a connection or configuration.

<a name="23c4b56d-4ae7-4f27-b1aa-f8eec7aa9ac8"></a>
<a name="25808ec144945724be66bed77bd5697f"></a>
###ResourceKind_RuleSetProduct
    GUID: '23c4b56d-4ae7-4f27-b1aa-f8eec7aa9ac8'
A _Ruleset Product_ is a ruleset that can be delivered to a customer.

<a name="2d4f4340-9612-473f-b7bb-22b900068a95"></a>
<a name="1470a08bc8b95c4282cd9f883a964094"></a>
###ResourceKind_Software
    GUID: '2d4f4340-9612-473f-b7bb-22b900068a95'
A _Software_ represents a (version) of code that implements an application.
<a name="88660668804e59b3bf31accead86bf18"></a>
# Examples
Instrument Manager 8.15.3, ASTM driver 8.12.22, etc.

<a name="d450c960-ac36-4404-8adb-e1e8292362ec"></a>
<a name="ff3327b10fe55895ba9ac7c20b7717fc"></a>
###ResourceKind_TableSpace
    GUID: 'd450c960-ac36-4404-8adb-e1e8292362ec'
A _Tablespace_ is a logical subdivision of a database that holds related
data together. In SQL databases, a tablespace contains a collection of
tables, indexes, and ancillary data.
<a name="11c3c02256ba5614b5aa884a56702e86"></a>
# Rationale
Databases usually contain huge amounts of data. Not all data in a datbase
is accessed according to the same patterns. As a result, the data is
segregated in several different storage segments, so that those segments
can be spread across multiple physical storage spaces.
Typically, data used very frequently would be kept on high-speed disk
drives, while archive data would be stored on slower but larger drives.
<a name="88660668804e59b3bf31accead86bf18"></a>
# Examples
<a name="e717e1d7ef095bb6be25ba35a662b4ac"></a>
## Instrument Manager
A Tablespace is called a "Database" in Caché. Examples include `IM-GBL`,
`IM-ARCHIVE`, `IM-TRACE`, etc;
Note that a Tablespace is a way to physically organize data in the database
based on their storage characteristic, and has nothing to do with Namespaces,
which are a way to logically organize data that is commonly used together.
<a name="5bb43e59817f58e09f71a5e2dc52bf8e"></a>
## LPM
A Tablespace represents one Oracle TableSpace. Examples include `V5HIST_DAT',
`V5HIST_IDX` etc.
<a name="ddb0fc902855508cb411d196cae09095"></a>
## EP Evaluator
DB-ISAM databases do not have the notion of tablespaces. As such, it is easier to have
a single tablespace in each database.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Component <-- Database
-   Component --> DataFile

<a name="9a910022-bb72-45c6-b858-93daa4955758"></a>
<a name="9c17aa80591a5c75a5e9a751c1eab04e"></a>
###ResourceKind_Tenant
    GUID: '9a910022-bb72-45c6-b858-93daa4955758'
A _Tenant_ resource represents a tenant.

<a name="2872294b-23f3-4be3-bc09-c0241e1e96a5"></a>
<a name="0aa14d69e7c5532cb7ae1c25253cabe0"></a>
###ResourceKind_User
    GUID: '2872294b-23f3-4be3-bc09-c0241e1e96a5'
A _User_ represents a user of the system. Users have access rights that
represent what they are allowed to do.
User resources cannot be configured by the user, they are shortcuts to
the user identity provider (Usually Cognito). They are provisioned
automatically.
Note that a user is not necessarily a human being. Additional users may
be used to represent processes (eg an ETL driver in an Instrument Manager
system) or roles (eg _the administrator_). Similarly, multiple different
users may correspond to the same actual person (eg someone might logon
as a regular user or as an administrative user)
<a name="e4ea8ec528da50de91bf09c62c574c0a"></a>
# Cognito replacement
The following text assumes that users are stored in a Cognito database.
The argument is the same for any other user authentication database.
<a name="11c3c02256ba5614b5aa884a56702e86"></a>
# Rationale
Users pulled from the Cognito user pool are encapsulated in resources for
the following reasons.
<a name="24f76842128c576eb42b5b38c1a84146"></a>
## Executive summary
*    Simplifies the handling of API keys needed to access Cognito.
*    Simplifies client code that no longer has to deal with token
     negociation.
*    Provides privacy using pseudonymization and only forwarding relevant
     PII.
*    Provides durability by keeping historical records even if the Cognito
     Entry is deleted.
Basically, the encapsulation works by only performing the operations that
are relevant to the task at hand (by explicitly writing code that does
it), instead of intercepting irrelevant operations and denying them (by
writing complex access IAM profiles and rules).
<a name="bcd29f9e443b54f5aa4a42406ed8f511"></a>
## Simplicity
Accessing Cognito from a client is not as easy as it may seem. The client
must provide an authentication token, and API key, etc to Cognito in order
to support its claims. Since client code is freely available to the end
user, none of these keys can be hardcoded in the client, and must be
negociated when neede. Moreover those tokens should be short lived so they
cannot be intercepted by the client and reused later.
Therefore, the client should contain code that keeps track of multiple
tokens, each with different lifetimes, and each with their own negociation
protocol.
Using the resource microservice instead, the client just has to query the
appropriate endpoint, providing its existing LabX authorization token.
The results are returned with an already agreed upon format.
<a name="5ace1228bd615208917c993b138ab992"></a>
## Security
All Cognito tokens and secret API keys remain on the server and are never
revealed to the client, greatly simplifying their management and
preventing leaks.
<a name="2e0499ec9a1e5b1586531e21829cf6dc"></a>
## Privacy
LabX power users may need to access the list of users, especially to grant
them access rights (to connection groups, for example) or insert them in
user groups. That does not mean however that power users have the right to
access all personal information beyond the name of the user.
Cognito records may contain extensive personal information about each user
that we do not want a power user to access. Restricting access to only the
name must be done by setting up complex access policies in IAM and
Cognito. Those rules must take into account the following privacy
requirements:
*   Users may request their data to be erased (eg using RGPD claims)
*   When the database covers multiple regions, power users from one region
    may not be allowed access to users to another region.
Using the resource microservice, the code can load the full information
from Cognito, then forward only the name to the client, further hiding it
if the user has requested his personal information to be erased, or if
the user belongs to another region.
Moreover, the encapsulation provides an identity based on an opaque GUID
that contains no decodable personal information, thus providing
pseudonymization.
<a name="9b3fd11f68c35c30a69ad70fe4feeee5"></a>
## Durability
Cognito records can be deleted at any time. However, LabX may need to keep
track of users even in the case they are deleted from the Cognito user
pool:
*   For traceability, all critical operations must be recorded with the
    identity of the operator. If this identification is a Cognito ID, the
    identification will be lost if the user record is removed from the
    Cognito pool. Using an encapsulation, user records are kept as
    resources even if they are deleted from Cognito.
*   We also may want to track changes made to the user records themselves.
    Each time Cognito user entries are synced into the resources, changes
    can be detected and recorded.
*   Since users are represented as resources, they can be used in any
    place where a resource is used to represent the _who_ in trace
    records.
<a name="26ec7f3d24f650af95cecd3711d52cc4"></a>
# Access
Resources of type user can be accessed from the generalized API. However,
the generalized API will _not_ automatically synchronize the users from
the identity provider.
For users to be automatically synchronized, use the following
[API](#f5870149d61d5763a45061ce855c9d33) instead:
    http://server/api/resource/1.0/users?autoupdate=true

<a name="5d7f99a5-d5ff-4715-8eff-8500d3e59dd7"></a>
<a name="8c5b91cfbac55c08bda715d17481ae1e"></a>
###ResourceKind_UserGroup
    GUID: '5d7f99a5-d5ff-4715-8eff-8500d3e59dd7'
  A _User Group_ represents a group of users. User groups are useful to
  manage access rights.

<a name="886f5412-20da-4415-b7f1-da5b62600243"></a>
<a name="6be8f8c83552518c85ddfabffcc3b923"></a>
###ResourceKind_VirtualMemory
    GUID: '886f5412-20da-4415-b7f1-da5b62600243'
The _Virtual Memory_ is the data storage of a computer consisting of the
total amount of working memory useable by application programs, including
physical memory and all paging space.
<a name="11c3c02256ba5614b5aa884a56702e86"></a>
# Rationale
Virtual memory becoming full may make applications fail to allocate additional
working memory. This may also indicate memory leaks.
Note that memory leaks are best detected by monitoring the working set size
of applications.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Component <-- Workstation
-   Component --> PhysicalMemory
-   Component --> DataFile

<a name="a3047565-0717-4032-9f2e-011485b8e83a"></a>
<a name="e46618d376855b3286395a96973deb36"></a>
###ResourceKind_Workstation
    GUID: 'a3047565-0717-4032-9f2e-011485b8e83a'
  A _Workstation_ represents a physical or virtual machine having its own
  dedicated resources (disk space, processor, etc.) that can host processes.


Resource Link Kinds
-------------------

<a name="d799c4b4-f010-4b10-b201-42d9bef64339"></a>
<a name="475471a069495d8ca93a880c995f241a"></a>
###ResourceLinkKind_Child
    GUID: 'd799c4b4-f010-4b10-b201-42d9bef64339'
A "Child" link unites a parent organization to its children sub-
organizations.
The "Child" relationship is expected to form a tree-like structure where
every resource has at most one parent. It represent the fact that the
responsibility of the parent organization extends over all its children,
ie the managing body of a parent is also responsible for the correct
operation of the children.
<a name="266c5f4305d056a4a39dd12512f4983b"></a>
####Typical Usages
 | Master     | Element    | Meaning
 |------------|------------|-------------------------------------------------
 | Laboratory | Laboratory | The element is a specialised lab
 | Laboratory | Middleware | The middleware is under responsibility of the lab
 | Laboratory | Instrument | The instrument is under responsibility of the lab

<a name="c4648aa6-ccd6-4f86-9f75-274ba53600c6"></a>
<a name="c0bb0a5796ea52e9ade1709bfcd3807f"></a>
###ResourceLinkKind_Component
    GUID: 'c4648aa6-ccd6-4f86-9f75-274ba53600c6'
The _Component_ link unites some kind of (software or hardware) device with
its parts.
It is usually considered that the composite resource needs all its
components to work properly. If one of the components of a composite
resource fails, the whole composite resource is in a failed state also,
or at least operating in a sub-optimal fashion.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-  Middleware --> Connection
-  Instrument --> AnalyticalUnit
-  AnalyticalProcessMonitor --> Connection
-  AnalyticalProcessMonitor --> Database

<a name="5196d206-a507-4880-a52c-23288ec1b895"></a>
<a name="f9d05b9b1f295d3e99dcc2b87845a4b3"></a>
###ResourceLinkKind_Configuration
    GUID: '5196d206-a507-4880-a52c-23288ec1b895'
The _Configuration_ link unites a configuration with the connections that
use that configuration.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Configuration --> Connection

<a name="2924dd58-72f6-4c3d-93eb-cd2bfc1db3d9"></a>
<a name="b37aac2b81e355f3b209e30c6a3de0a8"></a>
###ResourceLinkKind_Connection
    GUID: '2924dd58-72f6-4c3d-93eb-cd2bfc1db3d9'
The _Connection_ link unites a software connection module with the
equipment it communicates with.
To avoid ambiguous situations, a connection is never connected to another
connection.
Note that the type of data exchanged by the connection and the device
is not modeled. Whether it is medical data or stock quotes is irrelevant.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Connection --> Instrument
-   Connection --> Middleware

<a name="3075f69c-d115-4b7d-8f3d-dad5a4d10d91"></a>
<a name="e9302978acbc5661b74835f349b699c1"></a>
###ResourceLinkKind_Content
    GUID: '3075f69c-d115-4b7d-8f3d-dad5a4d10d91'
The _Content_ link unites a group with each of its elements.
Every kind of resource may have a corresponding "group" kind that behaves
the same way as its elements. For exemple, "user" resource can be
grouped in "user groups", which mostly behave as a single user.
The current LabX implementation recognizes only the "Connection Group"
kind, that groups connections.
A resource may be member of any number of groups.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   ConnectionGroup --> Connection
-   UserGroup --> User
-   MiddlewareGroup --> Middleware

<a name="c49f7cc5-e9b3-42f7-aa8a-a6d547dc9d10"></a>
<a name="748a2c1ec8f4596dbdce705e538f553e"></a>
###ResourceLinkKind_Host
    GUID: 'c49f7cc5-e9b3-42f7-aa8a-a6d547dc9d10'
The _Host_ link unites a master resource that "hosts" or "contains"
an element resource that needs the master to function correctly.
<a name="11c3c02256ba5614b5aa884a56702e86"></a>
# Rationale
The Host link unites an element resource that needs a master resource to
work properly. This is essentially the reverse of a Component link.
Both kinds of links unite a large item such as a workstation to a smaller
item such as a disk drive. They are both used to describe the relationships
between technical equipment.
When the items are linked by a Component link, this means that the master
cannot perform its work if the element is not fully functional. For example,
a workstation cannot function if its disk drive is broken. However, if the
disk is fine and the workstation is broken, data on the disk can still be
accessed by a different channel.
When the items are linked by a Host link, this means that the element cannot
perform its work if the master is not fully functional. For example, a data
file cannot be retrieved if the disk drive that hosts it is broken. However,
the disk drive functions correctly even if one of the datafile it hosts is
corrupted.

<a name="26449177-7c4d-41b6-9349-c8fb3ce751bc"></a>
<a name="62cedbcc3c0258528afb94780e8eef01"></a>
###ResourceLinkKind_Instance
    GUID: '26449177-7c4d-41b6-9349-c8fb3ce751bc'
The _Instance_ link unites a software component with resources that use
one or more copies of that software.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Software --> Connection
-   Software --> AnalyticalProcessMonitor
-   Software --> Middleware
-   Software --> Configuration
-   Software --> RuleSet

<a name="3f72bb16-602f-4608-a091-ee10721d1be7"></a>
<a name="c50d26e35b4e572585bfc40e081a5600"></a>
###ResourceLinkKind_Location
    GUID: '3f72bb16-602f-4608-a091-ee10721d1be7'
The _Location_ link unites a location with the connections defined in
that location.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Laboratory --> Connection

<a name="713d7a7a-a89a-4ab9-bf8a-28da2c135002"></a>
<a name="ff8277f136585e22894d55bb996d1801"></a>
###ResourceLinkKind_Monitor
    GUID: '713d7a7a-a89a-4ab9-bf8a-28da2c135002'
The _Monitor_ link unites a monitoring product with the equipment that it
monitors.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   AnalyticalProcessMonitor --> Instrument

<a name="aff0d320-9909-4d14-addb-f2d0982ded84"></a>
<a name="425d252abbef5db08c041a9b3a63a25a"></a>
###ResourceLinkKind_ReadAccess
    GUID: 'aff0d320-9909-4d14-addb-f2d0982ded84'
The _ReadAccess_ link unites a resource (typically an actor such as a
user) with another resource visible by that actor.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   User --> ConnectionGroup
-   User --> Middleware

<a name="1979ff93-fb60-4aa6-91a2-fe83d9ce3dc3"></a>
<a name="d973a3f9f37b5d29a16854f00457b894"></a>
###ResourceLinkKind_Site
    GUID: '1979ff93-fb60-4aa6-91a2-fe83d9ce3dc3'
The _Site_ link unites a site with the connections defined in
that location.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Laboratory --> Connection

<a name="a2c387f8-8d5d-47e5-9c98-a5e21645fc4f"></a>
<a name="c5ac6634840c5f57b1d68bb32321cabd"></a>
###ResourceLinkKind_Version
    GUID: 'a2c387f8-8d5d-47e5-9c98-a5e21645fc4f'
The _Version_ link unites a generic resource with a versioned vision of
itself.
<a name="914265aecb515bd4aa7ad8dfe3423368"></a>
# Links
-   Software --> Software
<a name="88660668804e59b3bf31accead86bf18"></a>
# Examples
  "Instrument Manager 8.15" is a version of "Instrument Manager"

<a name="26140d9d-97e7-4f6e-beec-92a7e4ab0c6d"></a>
<a name="20357ea702c651f8badb4ef2e6c023e8"></a>
###ResourceLinkKind_WriteAccess
    GUID: '26140d9d-97e7-4f6e-beec-92a7e4ab0c6d'
The _WriteAccess_ link unites a resource (typically an actor such as a
user) with another resource modifiable by that actor.


Resource Property Kinds
-----------------------

<a name="df8aee43-4573-456c-9d28-6ac42d1baf58"></a>
<a name="1e0e7e1ba3195e49b301313b24ee3e68"></a>
###ResourcePropertyKind_FailoverMode
    GUID: 'df8aee43-4573-456c-9d28-6ac42d1baf58'
The _Failover Mode_ property gives additional information about failover modes
in high availability configurations.
<a name="4446b1d3a29f5ed8857dd5d177babe2d"></a>
# Applies to
Workstation :    How that workstation participates in a failover scenario
Middleware :     How all workstations in that middleware participate in the
                 failover scenario.
                 Example: "Both primary and failover are managed by arbiter"
<a name="e779c820d2545caaade02d9d4ed908ae"></a>
# Format
{
    "description": "some descriptive text"
}
description:     A descriptive text. This can be anything that describes the
                 failover mode or scenario.

<a name="8d45af1f-e176-4bdf-b05f-a5b2c9a34962"></a>
<a name="0f8dc978bf555edc91cd161a4c726079"></a>
###ResourcePropertyKind_NetworkAddresses
    GUID: '8d45af1f-e176-4bdf-b05f-a5b2c9a34962'
The _Network Addresses_ property gives the collection of addresses of a
workstation or other network equipment.
<a name="e779c820d2545caaade02d9d4ed908ae"></a>
# Format
 {
     "ipv4": ["IP-1", "IP-2", etc],
     "vipv4": ["VIP-1", "VIP-2", etc]
 }
 ipv4:     the collection of IP V4 addresses, as a 4-number dotted
           notation. This should be an array.
 vipv4:    the collection of virtual IP V4 address. This should be
           the empty list if no VIP is attributed to the workstation.
           The VIP listed here *may*, but are not required to,
           be also listed in the ipv4 array.

Appendix - About Definitions
============================

Definitions are building blocks of the configuration.

Definition types
----------------

Each definition has a _type_. Definitions of the same type are grouped together
and form something like an SQL _table_.

Some examples of types (note that all types listed here do not necessarily
exist in LabX):

- _Resources_ which are devices, agents, services etc actively participating
  to the lab operation.

- _KPIs_ which represent each of the Key Performance Indicators that are
  published by LabX.

- _Tests_ which describe the tests performed by the lab, for example `WBC`

- _Fluids_ which describe the fluids on which tests are performed by the
  lab.

Each definition type is obtained using a REST resource within a service.
Sometimes, the name of the type corresponds to the name of the service, but
one service may make use of multiple definition types.

Examples:

    /api/resource/1.0/resources
    /api/resource/1.0/resourcekinds


Properties
----------

A definition has the following base properties. Each type of definition may
add additional properties that are useful for that particular type (for example,
Test definitions would include a list of instruments on which the test can
be performed)

- A _Unique ID_. This uniquely identifies the definition across the whole
  known universe. The unique ID is implemented as a GUID. Technically, the
  GUID of a definition should be fully opaque, not coding any information
  (ie a fully random GUID). However, it may be useful, in some rare cases,
  for the GUID to be derived from properties of the definition; this should
  be motivated.

- A _Name_. This is used when the definition is being displayed to the end user.
  It should be representative within the user context, but might not be enough
  to globally identify the object being referred to (ie, multiple definitions
  might have the same name if they are never shown together in a given context)

- An optional _Short Name_. This is used when the definition is being displayed
  to the end user in grids. The semantics of the short name is similar to the
  name. When the short name is not given, the name is used instead.

- An optional _Systematic Name_. This is used during configuration, typically
  in pick lists. The Systematic Name is basically the same as the Name, but
  bears a more systematic naming convention, to help administrators retrieve
  things more easily. If the Systematic Name is not given, the Name is used
  instead.

- An optional _Ordering Key_. This is used when showing multiple definitions
  in a list. Although not shown to the user, the Ordering key is used to sort
  the definition in ascending order of that key. When two definitions have
  the sampe ordering key, they are sorted in alphabetical order of the name
  being displayed (ie name, short name or systematic name)

- An optional _Technical description_. This is used to precisely describe the
  definition: what it is, what it is used for, etc. Tenants are free to
  use this for any purpose.

Example
-------

- A definition that represents a printer.
  - _Type_ is `resource`.
  - _Name_ is `Color laser printer`. This is how end users will see the printer
    in their application.
  - _Short Name_ is `Color Prt`
  - _Systematic Name_ is `Printer - 2nd Floor - Laserjet MX3400`. This is shown
    to administrators, eg when they are granting access rights to the printer
    for a user.
  - _Kind_ is `Printer`.

Definitions vs Kinds
--------------------

_Kinds_ are special cases of definitions, that represent a broad class of
objects that share a common functionality or purpose.

For example, each _resource_ (see the Resource service for more details) has
a kind that indicates its purpose. The kind may be `Printer`, `Analyzer`,
`Desktop computer`, etc.

When obtaining the list of definitions of a given type where a kind is defined,
it is possible to filter according to the kind using the `kind` query parameter;
the kind being a definition, its unique ID should be given.

    /api/resource/1.0/resources?kind=154eb46e-7933-40fd-8f47-78dbbac3c536

Example: units vs unit kinds:

| Unit   | Unit Kind |
| ----   | --------- |
| Metre  | Distance  |
| Mile   | Distance  |
| Litre  | Volume    |
| Gallon | Volume    |

Sharing of the Unique Id
------------------------

It is possible that two definitions, belonging to two tenants, will have the
same unique id. This indicates that the two definitions intrinsically represent
the same object or concept. This is typically the case for kinds.

Appendix - Useful links
============

Convince IE to display JSON
---------------------------


https://stackoverflow.com/questions/2483771/how-can-i-convince-ie-to-simply-display-application-json-rather-than-offer-to-do

___

This document was generated automatically as part of the automated build
process.

Version: 1.0.0.591
</xmp>

<script src="https://strapdownjs.com/v/0.2/strapdown.js"></script>
<script>
    mermaid.initialize({startOnLoad:true});
</script>

</body></html>
